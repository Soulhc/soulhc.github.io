<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java知识点随记</title>
    <link href="undefined2019/11/08/summary/"/>
    <url>2019/11/08/summary/</url>
    
    <content type="html"><![CDATA[<h5 id="Collection集合（单列集合）：集合下分为List集合和set集合"><a href="#Collection集合（单列集合）：集合下分为List集合和set集合" class="headerlink" title="Collection集合（单列集合）：集合下分为List集合和set集合"></a>Collection集合（单列集合）：集合下分为List集合和set集合</h5><h6 id="list接口"><a href="#list接口" class="headerlink" title="list接口"></a>list接口</h6><p>List下主要包括  vactor  ArrayList(底层为数组：查询速度较快，增删比较慢)  LinkedList（底层为链表，查询速度较慢，增删较快） 三个特点如下：</p><ol><li>有序集合，即存入什么顺序,查询出来就什么顺序</li><li>可以存入重复元素。即：1,2,1</li><li>具有索引，可以使用for循环</li></ol><h6 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h6><p>set下包括  TreeSet 和 HashSet（底层为Hash表，hash表由数组+链表/红黑树组成，查询速度超快）使用时，存入的类型必须重写了HashCode和equals方法，否则会存入相同的数据。  三个特点如下：</p><ol><li>不可以存入重复元素</li><li>无序  存入的数据查询出来时有可能相同，也有可能不同</li><li>没有索引</li></ol><p>LinkedHashSet继承与HashSet  数据结构为（数组+链表/红黑树+链表）  特点：有序  存入什么数据，拿出来即什么数据。  主要多加了一个链表来记录集合中的顺序。</p><h6 id="Collections工具类下边的记个方法"><a href="#Collections工具类下边的记个方法" class="headerlink" title="Collections工具类下边的记个方法"></a>Collections工具类下边的记个方法</h6><ol><li><p>addAll(list，参数)  第一个参数为集合，第二个参数为集合中所添加的数据。 第二个参数为（可变参数），可以根据自己的需要任意添加。</p></li><li><p>Shuffle 打乱集合的数据，即存入 1 3 2 取出时有可能1，2，3 或者3,2,1等等   主要打乱顺序</p></li><li><p>sort()一个参数 对集合中的数据进行排序。  如果集合中使用自定义的类型时需要实现Comparable接口并且实现compareTo方法才能生效，否则报错</p></li><li><p>sort(集合，排序规则)两个参数  排序规则new Comparator<Integer>（）{}匿名内部类，必须实现一个方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1,Integer o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1 - o2; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> o2 - o1; <span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Student&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1,Student o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result =  <span class="keyword">return</span> o1.age - o2.age; <span class="comment">//升序  按照年龄排序，如何年龄相同按照名字首字母排序</span></span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">            result = o1.getName().charAt(<span class="number">0</span>) - o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h6 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h6><p>哈希值:是一个十进制的整数，有系统随机给出(就是对象的地址值，是一个逻辑地址,是模拟出来的地址，不是实际存储的物理地址）<br>int hashCode()返回该对象的哈希码值。<br>hashCode方法的源码：<br>    public native int hashCode();<br>    native:代表该方法调用的是本地操作系统的方法<br>    哈希表：初始值为16个<br>    两个元素不同，但哈希值相同。成为哈希冲突</p><p>jdk1.8之前：哈希表=数组+链表<br>jdk1.8之后：哈希表=数组+链表；</p><p>哈希表=数组+红黑树（提高查询效率）  如果链表的长度超过8个之后则自动转为红黑树结构(折半查 找)<br>实现Comparable接口，重写比较的规则compareTo方法<br>    如果return this.age - o.age;为升序排序；<br>    return o.age - this.age;为降序排序；</p><h5 id="Map集合（双列集合）："><a href="#Map集合（双列集合）：" class="headerlink" title="Map集合（双列集合）："></a>Map集合（双列集合）：</h5><h6 id="Map集合特点："><a href="#Map集合特点：" class="headerlink" title="Map集合特点："></a>Map集合特点：</h6><ol><li>Map集合是一个双列集合，一个元素包含两个值（一个key,一个value）</li><li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li><li>Map集合的元素，key是不允许重复的,value是可以重复的</li><li>Map集合中的元素，key和value是一一对应</li></ol><p>java.util.HashMap&lt;k,v&gt;结合 implements Map&lt;k,v&gt;接口</p><h6 id="HashMap集合的特点："><a href="#HashMap集合的特点：" class="headerlink" title="HashMap集合的特点："></a>HashMap集合的特点：</h6><ol><li>HashMap集合底层是哈希表：查询的速度特别的快<pre><code>JDK1.8之前：数组+单向链表   JDK1.8值后：数组+单向链表/红黑树（链表的长度超过8即自动为红黑树）  提高查询的速度</code></pre></li><li>hasMmap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致<br> java.util.LinkedHashMap&lt;k,v&gt;集合 extends HashMap&lt;k,v&gt;集合<br>  LinkedHashMap的特点<ol><li>LinkedHashMap集合底层是哈希表+链表（保证迭代的书序）</li><li>LinkedHashMap集合是一个有序的集合，存储元素和取出元素是一致的</li></ol></li></ol><p>Map.Entry&lt;K,V&gt;：在Map接口中有一个内部接口Entry<br>            作用：当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象，键与值的映射关系）–&gt;结婚证</p><p>HashTable:底层是一个哈希表，是一个线程安全的集合。是单线程集合速度慢。<br>HashMap:底层是一个哈希表，是一个线程不安全的集合，是多线程的集合。速度快</p><p>HashMap集合（之前所学的所有集合）：可以存储null值，null键<br>Hashtable集合，不能存储null值，null键</p><p>Hashtable和vector集合一样，在jdk1.2版本之后被更先进的集合（hashMap,ArrayList）取代            </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>长记英语单词</title>
    <link href="undefined2019/11/07/my-first-blog/"/>
    <url>2019/11/07/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>application 应用程式 应用、应用程序</p><p>application framework 应用程式框架、应用框架 应用程序框架</p><p>architecture 架构、系统架构 体系结构</p><p>argument 引数（传给函式的值）。叁见 parameter 叁数、实质叁数、实叁、自变量</p><p>array 阵列 数组</p><p>arrow operator arrow（箭头）运算子 箭头操作符</p><p>assembly 装配件</p><p>assembly language 组合语言 汇编语言</p><p>assert(ion) 断言</p><p>assign 指派、指定、设值、赋值 赋值</p><p>assignment 指派、指定 赋值、分配</p><p>assignment operator 指派（赋值）运算子 = 赋值操作符</p><p>associated 相应的、相关的 相关的、关联、相应的</p><p>associative container 关联式容器（对应 sequential container） 关联式容器</p><p>atomic 不可分割的 原子的</p><p>attribute 属性 属性、特性</p><p>audio 音讯 音频</p><p>A.I. 人工智慧 人工智能</p><p>background 背景 背景（用於图形着色） 后台（用於行程）</p><p>backward compatible 回溯相容 向下兼容</p><p>bandwidth 频宽 带宽</p><p>base class 基础类别 基类</p><p>base type 基础型别 (等同於 base class)</p><p>batch 批次（意思是整批作业） 批处理</p><p>benefit 利益 收益</p><p>best viable function 最佳可行函式 最佳可行函式 （从 viable functions 中挑出的最佳吻合者）</p><p>binary search 二分搜寻法 二分查找</p><p>binary tree 二元树 二叉树</p><p>binary function 二元函式 双叁函数</p><p>binary operator 二元运算子 二元操作符</p><p>binding 系结 绑定</p><p>bit 位元 位</p><p>bit field 位元栏 位域</p><p>bitmap 位元图 位图</p><p>bitwise 以 bit 为单元逐一┅</p><p>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝</p><p>block 区块,区段 块、区块、语句块</p><p>boolean 布林值（真假值，true 或 false） 布尔值</p><p>border 边框、框线 边框</p><p>brace(curly brace) 大括弧、大括号 花括弧、花括号</p><p>bracket(square brakcet) 中括弧、中括号 方括弧、方括号</p><p>breakpoint 中断点 断点</p><p>build 建造、构筑、建置（MS 用语）</p><p>build－in 内建 内置</p><p>bus 汇流排 总线</p><p>business 商务,业务 业务</p><p>buttons 按钮 按钮</p><p>byte 位元组（由 8 bits 组成） 字节</p><p>cache 快取 高速缓存</p><p>call 呼叫、叫用 调用</p><p>callback 回呼 回调</p><p>call operator call（函式呼叫）运算子调用操作符 ###### （同 function call operator）</p><p>candidate function 候选函式 候选函数 ###### （在函式多载决议程序中出现的候选函式）</p><p>chain 串链（例 chain of function calls） 链</p><p>character 字元 字符</p><p>check box 核取方块 (i.e. check button) 复选框</p><p>checked exception 可控式异常(Java)</p><p>check button 方钮 (i.e. check box) 复选按钮</p><p>child class 子类别（或称为derived class, subtype） 子类</p><p>class 类别 类</p><p>class body 类别本体 类体</p><p>class declaration 类别宣告、类别宣告式 类声明</p><p>class definition 类别定义、类别定义式 类定义</p><p>class derivation list 类别衍化列 类继承列表</p><p>class head 类别表头 类头</p><p>class hierarchy 类别继承体系, 类别阶层 类层次体系</p><p>class library 类别程式库、类别库 类库</p><p>class template 类别模板、类别范本 类模板</p><p>class template partial specializations ###### 类别模板偏特化 类模板部分特化</p><p>class template specializations ###### 类别模板特化 类模板特化</p><p>cleanup 清理、善后 清理、清除</p><p>client 客端、客户端、客户 客户</p><p>client－server 主从架构 客户/服务器</p><p>clipboard 剪贴簿 剪贴板</p><p>clone 复制 克隆</p><p>collection 群集 集合</p><p>combo box 复合方块、复合框 组合框</p><p>command line 命令列 命令行 (系统文字模式下的整行执行命令)</p><p>communication 通讯 通讯</p><p>compatible 相容 兼容</p><p>compile time 编译期 编译期、编译时</p><p>compiler 编译器 编译器</p><p>component 组件 组件</p><p>composition 复合、合成、组合 组合</p><p>computer 电脑、计算机 计算机、电脑</p><p>concept 概念 概念</p><p>concrete 具象的 实在的</p><p>concurrent 并行 并发</p><p>configuration 组态 配置</p><p>connection 连接，连线（网络,资料库） 连接</p><p>constraint 约束（条件）</p><p>construct 构件 构件</p><p>container 容器 容器 ###### （存放资料的某种结构如 list, vector…）</p><p>containment 内含 包容</p><p>context 背景关系、周遭环境、上下脉络 环境、上下文</p><p>control 控制元件、控件 控件</p><p>console 主控台 控制台</p><p>const 常数（constant 的缩写，C++ 关键字）</p><p>constant 常数（相对於 variable） 常量</p><p>constructor（ctor） 建构式 构造函数 ###### （与class 同名的一种 member functions）</p><p>copy (v) 复制、拷贝 拷贝</p><p>copy (n) 复件, 副本</p><p>cover 涵盖 覆盖</p><p>create 创建、建立、产生、生成 创建</p><p>creation 产生、生成 创建</p><p>cursor 游标 光标</p><p>custom 订制、自定 定制</p><p>data 资料 数据</p><p>database 资料库 数据库</p><p>database schema 数据库结构纲目</p><p>data member 资料成员、成员变数 数据成员、成员变量</p><p>data structure 资料结构 数据结构</p><p>datagram 资料元 数据报文</p><p>dead lock 死结 死锁</p><p>debug 除错 调试</p><p>debugger 除错器 调试器</p><p>declaration 宣告、宣告式 声明</p><p>deduction 推导（例：template argument deduction） 推导、推断</p><p>default 预设 缺省、默认</p><p>defer 延缓 推迟</p><p>define 定义 预定义</p><p>definition 定义、定义区、定义式 定义</p><p>delegate 委派、委托、委任 委托</p><p>delegation （同上）</p><p>demarshal 反编列 散集</p><p>dereference 提领（取出指标所指物体的内容） 解叁考</p><p>dereference operator dereference（提领）运算子 * 解叁考操作符</p><p>derived class 衍生类别 派生类</p><p>design by contract 契约式设计</p><p>design pattern 设计范式、设计样式 设计模式 ※ 最近我比较喜欢「设计范式」一词</p><p>destroy 摧毁、销毁</p><p>destructor 解构式 析构函数</p><p>device 装置、设备 设备</p><p>dialog 对话窗、对话盒 对话框</p><p>directive 指令（例：using directive） (编译)指示符</p><p>directory 目录 目录</p><p>disk 碟 盘</p><p>dispatch 分派 分派</p><p>distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)</p><p>document 文件 文档</p><p>dot operator dot（句点）运算子 . (圆)点操作符</p><p>driver 驱动程式 驱动（程序）</p><p>dynamic binding 动态系结 动态绑定</p><p>efficiency 效率 效率</p><p>efficient 高效 高效</p><p>end user 终端用户</p><p>entity 物体 实体、物体</p><p>encapsulation 封装 封装</p><p>enclosing class 外围类别（与巢状类别 nested class 有关）外围类</p><p>enum (enumeration) 列举（一种 C++ 资料型别） 枚举</p><p>enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器</p><p>equal 相等 相等</p><p>equality 相等性 相等性</p><p>equality operator equality（等号）运算子 == 等号操作符</p><p>equivalence 等价性、等同性、对等性 等价性</p><p>equivalent 等价、等同、对等 等价</p><p>escape code 转义码 转义码</p><p>evaluate 评估、求值、核定 评估</p><p>event 事件 事件</p><p>event driven 事件驱动的 事件驱动的</p><p>exception 异常情况 异常</p><p>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明</p><p>exception handling 异常处理、异常处理机制 异常处理、异常处理机制</p><p>exception specification 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范</p><p>exit 退离（指离开函式时的那一个执行点） 退出</p><p>explicit 明白的、明显的、显式 显式</p><p>export 汇出 引出、导出</p><p>expression 运算式、算式 表达式</p><p>facility 设施、设备 设施、设备</p><p>feature 特性</p><p>field 栏位,资料栏（Java） 字段, 值域（Java）</p><p>file 档案 文件</p><p>firmware 韧体 固件</p><p>flag 旗标 标记</p><p>flash memory 快闪记忆体 闪存</p><p>flexibility 弹性 灵活性</p><p>flush 清理、扫清 刷新</p><p>font 字型 字体</p><p>form 表单（programming 用语） 窗体</p><p>formal parameter 形式叁数 形式叁数</p><p>forward declaration 前置宣告 前置声明</p><p>forwarding 转呼叫,转发 转发</p><p>forwarding function 转呼叫函式,转发函式 转发函数</p><p>fractal 碎形 分形</p><p>framework 框架 框架</p><p>full specialization 全特化（ref. partial specialization）</p><p>function 函式、函数 函数</p><p>function call operator 同 call operator</p><p>function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象</p><p>function overloaded resolution 函式多载决议程序 函数重载解决（方案）</p><p>functionality 功能、机能 功能</p><p>function template 函式模板、函式范本 函数模板</p><p>functor 仿函式 仿函式、函子</p><p>game 游戏 游戏</p><p>generate 生成</p><p>generic 泛型、一般化的 一般化的、通用的、泛化</p><p>generic algorithm 泛型演算法 通用算法</p><p>getter (相对於 setter) 取值函式</p><p>global 全域的（对应於 local） 全局的</p><p>global object 全域物件 全局对象</p><p>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符</p><p>group 群组</p><p>group box 群组方块 分组框</p><p>guard clause 卫述句 (Refactoring, p250) 卫语句</p><p>GUI 图形介面 图形界面</p><p>hand shaking 握手协商</p><p>handle 识别码、识别号、号码牌、权柄 句柄</p><p>handler 处理常式 处理函数</p><p>hard－coded 编死的 硬编码的</p><p>hard－copy 硬拷图 屏幕截图</p><p>hard disk 硬碟 硬盘</p><p>hardware 硬体 硬件</p><p>hash table 杂凑表 哈希表、散列表</p><p>header file 表头档、标头档 头文件</p><p>heap 堆积 堆</p><p>hierarchy 阶层体系 层次结构（体系）</p><p>hook 挂钩 钩子</p><p>hyperlink 超链结 超链接</p><p>icon 图示、图标 图标</p><p>IDE 整合开发环境 集成开发环境</p><p>identifier 识别字、识别符号 标识符</p><p>if and only if 若且唯若 当且仅当</p><p>Illinois 伊利诺 伊利诺斯</p><p>image 影像 图象</p><p>immediate base 直接的（紧临的）上层 base class。 直接上层基类</p><p>immediate derived 直接的（紧临的）下层 derived class。 直接下层派生类</p><p>immutability 不变性</p><p>immutable 不可变（的）</p><p>implement 实作、实现 实现</p><p>implementation 实作品、实作体、实作码、实件 实现</p><p>implicit 隐喻的、暗自的、隐式 隐式</p><p>import 汇入 导入</p><p>increment operator 累加运算子 ++ 增加操作符</p><p>infinite loop 无穷回圈 无限循环</p><p>infinite recursive 无穷递回 无限递归</p><p>information 资讯 信息</p><p>infrastructure 公共基础建设</p><p>inheritance 继承、继承机制 继承、继承机制</p><p>inline 行内 内联</p><p>inline expansion 行内展开 内联展开</p><p>initialization 初始化（动作） 初始化</p><p>initialization list 初值列 初始值列表</p><p>initialize 初始化 初始化</p><p>inner class 内隐类别 内嵌类</p><p>instance 实体 实例 ###### （根据某种表述而实际产生的「东西」）</p><p>instantiated 具现化、实体化（常应用於 template） 实例化</p><p>instantiation 具现体、具现化实体（常应用於 template） 实例</p><p>integer (integral) 整数（的） 整型（的）</p><p>integrate 整合 集成</p><p>interacts 交谈、互动 交互</p><p>interface 介面 接口</p><p>for GUI 介面 界面</p><p>interpreter 直译器 解释器</p><p>invariants 恒常性,约束条件 约束条件</p><p>invoke 唤起 调用</p><p>iterate 迭代（回圈一个轮回一个轮回地进行） 迭代</p><p>exception 异常情况 异常</p><p>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明</p><p>exception handling 异常处理、异常处理机制 异常处理、异常处理机制</p><p>exception specification 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范</p><p>exit 退离（指离开函式时的那一个执行点） 退出</p><p>explicit 明白的、明显的、显式 显式</p><p>export 汇出 引出、导出</p><p>expression 运算式、算式 表达式</p><p>facility 设施、设备 设施、设备</p><p>feature 特性</p><p>field 栏位,资料栏（Java） 字段, 值域（Java）</p><p>file 档案 文件</p><p>firmware 韧体 固件</p><p>flag 旗标 标记</p><p>flash memory 快闪记忆体 闪存</p><p>flexibility 弹性 灵活性</p><p>flush 清理、扫清 刷新</p><p>font 字型 字体</p><p>form 表单（programming 用语） 窗体</p><p>formal parameter 形式叁数 形式叁数</p><p>forward declaration 前置宣告 前置声明</p><p>forwarding 转呼叫,转发 转发</p><p>forwarding function 转呼叫函式,转发函式 转发函数</p><p>fractal 碎形 分形</p><p>framework 框架 框架</p><p>full specialization 全特化（ref. partial specialization）</p><p>function 函式、函数 函数</p><p>function call operator 同 call operator</p><p>function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象</p><p>function overloaded resolution 函式多载决议程序 函数重载解决（方案）</p><p>functionality 功能、机能 功能</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>